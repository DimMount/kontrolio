# Kontrolio: держите свои данные под контролем.
Kontrolio — простая библиотека валидации данных без дополнительных зависимостей, вдохновленная Laravel и Symfony.

## Настраиваем валидатор
Настройка Kontrolio и API валидации достаточно стандартны:
 
```php
$validator = new Validator($data, $rules, $messages);
$validator->validate();
```

Данные представляют из себя пары ключ-значение, т.е. атрибуты и их значения:

```php
$data = [
    'foo' => 'bar',
    'bar' => 'baz',
    'baz' => 'taz'
];
```

Правила валидации могут задаваться тремя разными способами:
1. Строки в стиле Laravel
2. Объекты классов-правил
3. Замыкания / функции обратного вызова

Вы можете совмещать объекты-правила и коллбэки, когда задаете несколько правил валидации для одного атрибута. Пример:

```php
$rules = [
    'one' => 'not_empty|length:5,15',
    'two' => new Email,
    'three' => function($value) {
        return $value === 'taz';
    },
    'four' => [
        function($value) {
            return is_numeric($value);
        },
        new GreaterThan(5),
    ]
];
```

Когда вы устанавливаете правила валидации в виде строки, валидатор, перед тем как применить правила к атрибуту, распарсит переданную строку в обычный массив правил. Поэтому когда вы пишете `'some' => 'not_empty|length:5,15'`, на выходе получается следующее:

```php
'some' => [
    new NotEmpty,
    new Length(5, 15)
]
```

Как видите, это довольно просто, но помните, что все аргументы, которые вы передаете после двоеточия, разделяя их запятыми, становятся аргументами конструктора для объекта правила валидации.

Когда вы пишете правило валидации в виде коллбэека, валидатор оборачивает его в специальный объект класса `Kontrolio\Rules\CallbackRuleWrapper`, чтобы следовать интерфейсу `Kontrolio\Rules\RuleInterface`.

## Опции правил валидации
### Разрешаем пустые значения
Отдельное правило валидации может быть пропущено, если валидируемое значение атрибута пусто. Если вы решили, что вам необходима данная опция, вы создаете объект правила используя именованный конструктор `allowingEmptyValue()` или вызывая метод `allowEmptyValue()` на уже существующем объекте:

```php
'some' => [
    MyRule::allowingEmptyValue(),
    // (new MyRule)->allowEmptyValue()
]
```

### Пропускаем отдельное правило валидации
Создавая новое правило валидации вы можете воспользоваться возможностью пропуска его валидации при соблюдении какого-то условия. Вы можете определить такое поведение, используя метод `canSkipValidation()`:

```php

class MyRule extends AbstractRule
{
    public function canSkipValidation($input = null)
    {
        return $input === 'bar';
    }

    // ...
}

```
## Правила-коллбэки
Правило-коллэк — это ничто иное как простое замыкание или функция обратного вызова, которая принимает единственным аргументом значение валидируемого атрибута и возвращает либо булевый результат валидации, либо массив опций, эквивалентных тем, что используются классами-правилами:

```php
    'foo' => function($value) {
        return is_string($value);
    },
    'bar' => function($value) {
        return [
            // required when array
            'valid' => $value === 'taz',
            
            // optionals
            'name' => 'baz', // rule identifier
            'empty_allowed' => true, // allowing empty value
            'skip' => false // don't allow skipping current rule validation,
            'violations' => [] // rule violations
        ];
    }
```

## Собственные правила
Естественно, ничто не мешает вам создавать собственные правила. Просто помните, что любое правило должно реализовывать интерфейс `Kontrolio\Rules\RuleInterface`, метод `isValid()` и иметь идентификатор. По умолчанию, для удобства идентификатор выводится абстрактным классом `Kontrolio\Rules\AbstractRule` и основывается на имени класса без учета пространства имён. Тем не менее, вы можете переопределить идентификатор, переопределив метод `getName()`.

Чтобы уведомить валидатор о новых правилам, вам необходимо добавить их в валидатор вручную, используя метод `Kontrolio\Validator::extendAvailableRules()`:

```php
Validator::extendAvailableRules([
   FirstRule::class,
   SecondRule::class
])
```

Также вы можете переопределить автоматически выводимые идентификаторы:

```php
Validator::extendAvailableRules([
   'foo' => FirstRule::class,
   'bar' => SecondRule::class
])
```

## Пропускаем полностью валидацию атрибута
Это не то же самое, что использование методов `allowEmptyValue()` или `canSkipValidation()` на правиле. Используя их, вы можете пропустить _это конкретное правило_. Тем не менее вы можете полностью отменить валидацию атрибута используя правило `Kontrolio\Rules\Core\Sometimes`. `Sometimes` указывает валидатору пропустить валидацию атрибута по другим правилам, если значение артибута пустое или `null`. Вот и всё. Вы можете поставить `Sometimes` в начало массива правил для атрибута или использовать соответствующий идентификатор в строке:

```php
$rules = [
    'one' => 'sometimes|length:5,15',
    // 'one' => [
    //     new Sometimes,
    //     new Length(5, 15)
    // ]
];
```

## Ошибки валидации и «нарушения» правил
Ошибки валидации задаются в едином и простом формате, который вам понравится:

```php
$messages = [
    'foo' => 'Foo cannot be null',
    'foo.length' => 'Wrong length of foo',
    'foo.length.min' => 'Foo is less than 3'
    // '[attribute].[rule].[violation]
];
```
Ключ каждого из сообщений может состоять из одного-трех сегментов, разделенных точками:
1. Имя атрибута
2. Идентификатор правила
3. Ключ «нарушения» правила

Имея эти параметры, вы можете кастомизировать свои ошибки валидации от самой общей до самой специфичной. Каждое «нарушение» устанавливается соответствующим правилом при проверке валидности значения атрибута. Поэтому когда вы создаете собственные правила валидации, не возбраняется, а даже поощряется определять такие «нарушения», чтобы предоставить широкие возможности кастомизации результатов валидации и соответствующих ошибок.